-- Top level cost assignment

Our goal here is to provide a formula for proportional cost assignment to language productions based off of the eventual instructions they will invoke and the operands of those instructions, where G is a grammar element. Cost assignments is parametric in the cost values assigned to OpCodes and Bytes which may vary from one namespace to another.

COST(G)          = DataCost(G) + OpCost(G)

/* This is the essential cost of instruction operands */

DataCost(G)      = COST(Byte) * ByteSize(G)

/* In the imminent case we'd like to quantify recurring sequences of OpCodes, this function is composable. The cost of an instruction
sequence is simply OpCost(...(OpCost(x))). This allows G to be a sequence of instructions and is essentially form of the quantification shown in the language assignments. */

OpCost(G)        = COST(OpCode) * Frequency(OpCode) + DataCost(OpCode)

/* Note that DataCost(OpCode) = COST(Byte) * ByteSize(OpCode) = COST(Byte) * 1 as bytecodes are exactly that...bytesized instructions */

-- Top level contract declaration
DContr. Contr ::= "contract" Name "(" [CPattern] ")" "=" "{" Proc "}" ;

-- Processes
PNil.    Proc4 ::= "Nil" ;
PValue.  Proc4 ::= Value ;
PVar.    Proc4 ::= Var ;
PDrop.   Proc3 ::= "*" Chan ;
PInject. Proc3 ::= "#" Chan ;
PLift.   Proc2 ::= Chan "!" "(" [Proc] ")" ;
PFoldL.  Proc1 ::= "sum" "(" Bind "/:" Bind ")" "{" Proc "}" ;
PFoldR.  Proc1 ::= "total" "(" Bind ":\\" Bind ")" "{" Proc "}" ;
PInput.  Proc1 ::= "for" "(" [Bind] ")" "{" Proc "}" ;
PChoice. Proc1 ::= "select" "{" [CBranch] "}" ;
PMatch.  Proc1 ::= "match" Proc "with" [PMBranch] ;
PNew.    Proc1 ::= "new" [Var] "in" Proc1 ;
PConstr. Proc1 ::= Name "(" [Proc] ")" ;
PPar.    Proc  ::= Proc "|" Proc1 ;
separator nonempty Proc "," ;
coercions Proc 4 ;

-- Channels
CVar.    Chan ::= Var ;
CQuote.  Chan ::= "@" Proc3 ;

-- Variable binding
InputBind.     Bind ::= CPattern "<-" Chan ;
CondInputBind. Bind ::= CPattern "<-" Chan "if" Proc ;
separator nonempty Bind ";" ;

-- Pattern match branches
PatternMatch. PMBranch ::= PPattern "=>" "{" Proc "}" ;
separator nonempty PMBranch "" ; 

-- Choice branch
Choice. CBranch ::= "case" [Bind] "=>" "{" Proc "}" ;
separator nonempty CBranch "" ;

-- Values
VQuant.   Value    ::= Quantity ;
VEnt.     Value    ::= Entity ;
QBool.    Quantity ::= RhoBool ;
QInt.     Quantity ::= Integer ;
QDouble.  Quantity ::= Double ;
QTrue.    RhoBool  ::= "true" ;
QFalse.   RhoBool  ::= "false" ;
EChar.    Entity   ::= Char ;
-- EDate.    Entity   ::= Datetime ;
EStruct.  Entity   ::= Struct ;
ECollect. Entity   ::= Collect ;
ETuple.   Entity   ::= "<" [Proc] ">" ;
StructConstr. Struct ::= Var "{" [Proc] "}" ;
CString. Collect ::= String ;
-- CArray.  Collect ::= Array ;
-- CList.   Collect ::= List ;

-- Variable patterns
VarPtVar.  VarPattern ::= Var ;
VarPtWild. VarPattern ::= "_" ;
separator VarPattern "," ;

-- Process patterns
PPtVar.    PPattern4 ::= VarPattern ;
PPtNil.    PPattern4 ::= "Nil" ;
PPtVal.    PPattern4 ::= ValPattern ;
PPtDrop.   PPattern3 ::= "*" CPattern ;
PPtInject. PPattern3 ::= "#" CPattern ;
PPtOutput. PPattern2 ::= CPattern "!" "(" [PPattern] ")" ;
PPtInput.  PPattern1 ::= "for" "(" [PatternBind] ")" "{" PPattern "}" ;
PPtMatch.  PPattern1 ::= "match" PPattern "with" [PatternPatternMatch] ;
PPtNew.    PPattern1 ::= "new" [VarPattern] "in" PPattern1 ;
PPtConstr. PPattern1 ::= Name "(" [PPattern] ")" ;
PPtPar.    PPattern  ::= PPattern "|" PPattern1 ;
separator PPattern "," ;
coercions PPattern 4 ;

-- Channel patterns
CPtVar.    CPattern ::= VarPattern ;
CPtQuote.  CPattern ::= "@" PPattern3 ;
CValPtrn.  CPattern ::= ValPattern ;
separator CPattern "," ;

-- Bind pattern
PtBind.   PatternBind ::= CPattern "<-" CPattern ;
separator nonempty PatternBind ";" ;

-- Pattern match branch pattern
PtBranch. PatternPatternMatch ::= PPattern "=>" "{" PPattern "}" ;
separator nonempty PatternPatternMatch "" ;

-- Value patterns -> COST(ValPattern) = 

VPtStruct. ValPattern ::= Var "{" [PPattern] "}" ;
VPtTuple. ValPattern ::= "<" [PPattern] ">" ;
VPtTrue. ValPattern ::= "true" ;
VPtFalse. ValPattern ::= "false" ;
VPtInt. ValPattern ::= Integer ;
VPtDbl. ValPattern ::= Double ;
VPtStr. ValPattern ::= String ;
--VPtString. ValPattern ::=  ;
--VPtArray.  ValPattern ::=  ;
--VPtList.   ValPattern ::=  ;
separator nonempty ValPattern "," ;

-- Names and variables
token Name (upper (letter | digit | '_' | '\'')*) ;
token Var (lower (letter | digit | '_' | '\'')*) ;

separator nonempty Var "," ;
separator nonempty Name "," ;
